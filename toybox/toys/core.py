import numpy as np
from matplotlib import pyplot as plt
from scipy.stats import multivariate_normal
from skimage import filters
from toybox.symmetry.operators import propagate
from toybox.symmetry.parsers import parse_hermann_mauguin
from toybox.tools import check_points, check_point, equivalent


class Points:

    def __init__(self,
                 starting_points=None,
                 symmetry=1,
                 auto_zero=True,
                 ):
        """A series of points related by symmetry.

        Use this class to define where the diffraction points should be in relation
        to one another.

        Parameters
        ----------
        starting_points : array_like
            (`n_points`, 3)
            Initial points, in the format (x, y, intensity)
        symmetry : :obj:int, :obj:str, optional
            Symmetry to apply to the points. Defaults to int:1 i.e. no symmetry.
        auto_zero : bool
            If True, automatically appends (0., 0., None) to the starting_points.

        """

        if starting_points is not None:
            starting_points = check_points(starting_points)
            self.starting_points = np.array(starting_points)
        else:
            self.starting_points = None
        if auto_zero:
            self.append_point((0., 0.))
        self.symmetry = symmetry

    def append_point(self, point):
        """Adds a point to the pattern.

        Parameters
        ----------
        point : array_like
            (x, y, [intensity])
            Coordinates of the point to add.

        """
        point = check_point(point)
        if self.starting_points is None:
            self.starting_points = np.array(point).reshape(1, -1)
        else:
            self.starting_points = np.vstack((self.starting_points, point))
        return self

    @property
    def points(self):
        """:class:`numpy.ndarray` The points in the array, generated by
        propagating the starting points through the specified symmetry.

        """
        operations = parse_hermann_mauguin(self.symmetry)
        points = propagate(self.starting_points, *operations)
        return points

    @points.setter
    def points(self, points):
        self.starting_points = check_points(points)

    @property
    def positions(self):
        """:class:`numpy.ndarray` The positions of all the :attr:`points`."""
        return self.points[:, :2].astype(float)

    @property
    def intensities(self):
        """:class:`numpy.ndarray` The intensities of all the :attr:`points`."""
        return self.points[:, 2]

    @intensities.setter
    def intensities(self, intensities):
        self.starting_points[:, 2] = intensities

    def to_shape(self, shape, scale=1.0):
        """Scales and translates the points into a bounding box of size `shape`.

        Parameters
        ----------
        shape : :obj:`tuple` of :obj:`int`
            The shape of the bounding box.
        scale : :obj:`float`, optional
            All the new points will fit within an ellipse of semi-major axes
            `scale`*`shape` from the centre to the edge of the bounding box.
            Defaults to 1.0.

        Returns
        -------
        :class:`numpy.ndarray`
            (n_points, 2)
            The transformed points.

        """
        offset = np.array(shape)/2
        scale_factor = scale * offset
        distance = np.nanmax(np.sqrt(np.sum(np.square(self.positions), axis=1)))
        return (self.positions/distance) * scale_factor + offset

    def __repr__(self):
        return "Array\n-----\nSymmetry: {}\n{}".format(self.symmetry,
                                                       self.points)

    def __eq__(self, other):
        if equivalent(self.points, other.points):
            return True
        else:
            return False


class Pattern(np.ndarray):
    """A class representing a toy pattern.

    Subclassing np.ndarray, this class simply extends the functionality of the
    array.

    """

    @classmethod
    def from_points(cls, points, shape=(100, 100), scale=1.0, blur=1.):
        """Creates a pattern from a set of points.

        Currently only Gaussian peaks are implemented.

        Parameters
        ----------
        points : Points, array_like
            Positions and intensities of the points in the array.
        shape : Shape of the final array.
        scale : float
            Maximum extent of the points. Should be less than 1.
        blur : float
            Level of gaussian blur to apply to the pattern.

        Returns
        -------
        Pattern
            An array simulating a diffraction pattern.

        """
        if not isinstance(points, Points):
            points = Points(points)
        positions = points.to_shape(shape, scale)
        dat = np.zeros(shape)
        x, y = np.mgrid[0: shape[0], 0: shape[1]]
        pos = np.empty(x.shape + (2,))
        pos[:, :, 0] = x
        pos[:, :, 1] = y
        for position, intensity in zip(positions, points.intensities):
            dat += intensity * multivariate_normal.pdf(pos, mean=position, cov=1)
        dat = filters.gaussian(dat, sigma=blur)
        return dat.view(cls)

    def plot(self, colorbar=False, cmap='gray'):
        """Plots the pattern using :mod:`matplotlib`.

        Parameters
        ----------
        colorbar : bool
            If `True`, the plot is produced with a color scale bar.
        cmap : str
            Set the color map of the plot. Can be any :mod:`matplotlib` color
            map name.

        """
        plt.imshow(self, interpolation='none', cmap=cmap)
        if colorbar:
            plt.colorbar()